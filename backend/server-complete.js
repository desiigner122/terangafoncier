import express from 'express';
import helmet from 'helmet';
import cors from 'cors';
import { getDatabase } from './config/database.js';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());

// JWT Secret (en production, utiliser une variable d'environnement)
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-here';

// Middleware d'authentification
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (token == null) return res.sendStatus(401);

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) return res.sendStatus(403);
    req.user = user;
    next();
  });
};

// Routes de base
app.get('/health', async (req, res) => {
  try {
    console.log('üîÑ Test de la base de donn√©es...');
    const db = await getDatabase();
    console.log('‚úÖ Base de donn√©es connect√©e');
    
    res.json({ 
      status: 'OK',
      message: 'Serveur Teranga Foncier - API Compl√®te',
      timestamp: new Date().toISOString(),
      database: 'Connected'
    });
  } catch (error) {
    res.status(500).json({ 
      status: 'ERROR',
      error: error.message 
    });
  }
});

// Test de base de donn√©es
app.get('/db-test', async (req, res) => {
  try {
    const db = await getDatabase();
    const users = db.prepare('SELECT COUNT(*) as count FROM users').get();
    const properties = db.prepare('SELECT COUNT(*) as count FROM properties').get();
    
    res.json({
      message: 'Base de donn√©es test√©e avec succ√®s',
      users: users.count,
      properties: properties.count
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ROUTES D'AUTHENTIFICATION

// Inscription
app.post('/api/auth/inscription', async (req, res) => {
  try {
    const { email, password, nom, prenom, telephone } = req.body;

    if (!email || !password || !nom || !prenom) {
      return res.status(400).json({ 
        error: 'Tous les champs requis doivent √™tre fournis' 
      });
    }

    const db = await getDatabase();
    
    // V√©rifier si l'utilisateur existe d√©j√†
    const existingUser = db.prepare('SELECT id FROM users WHERE email = ?').get(email);
    if (existingUser) {
      return res.status(400).json({ 
        error: 'Un utilisateur avec cet email existe d√©j√†' 
      });
    }

    // Hasher le mot de passe
    const hashedPassword = await bcrypt.hash(password, 10);

    // Cr√©er l'utilisateur
    const result = db.prepare(`
      INSERT INTO users (email, password, nom, prenom, telephone, role, created_at)
      VALUES (?, ?, ?, ?, ?, 'user', datetime('now'))
    `).run(email, hashedPassword, nom, prenom, telephone || null);

    // Cr√©er le token JWT
    const token = jwt.sign(
      { userId: result.lastInsertRowid, email },
      JWT_SECRET,
      { expiresIn: '24h' }
    );

    res.status(201).json({
      message: 'Utilisateur cr√©√© avec succ√®s',
      token,
      user: {
        id: result.lastInsertRowid,
        email,
        nom,
        prenom,
        role: 'user'
      }
    });

  } catch (error) {
    console.error('Erreur lors de l\'inscription:', error);
    res.status(500).json({ error: 'Erreur interne du serveur' });
  }
});

// Connexion
app.post('/api/auth/connexion', async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ 
        error: 'Email et mot de passe requis' 
      });
    }

    const db = await getDatabase();
    
    // R√©cup√©rer l'utilisateur
    const user = db.prepare('SELECT * FROM users WHERE email = ?').get(email);
    if (!user) {
      return res.status(401).json({ 
        error: 'Email ou mot de passe incorrect' 
      });
    }

    // V√©rifier le mot de passe
    const validPassword = await bcrypt.compare(password, user.password);
    if (!validPassword) {
      return res.status(401).json({ 
        error: 'Email ou mot de passe incorrect' 
      });
    }

    // Cr√©er le token JWT
    const token = jwt.sign(
      { userId: user.id, email: user.email },
      JWT_SECRET,
      { expiresIn: '24h' }
    );

    res.json({
      message: 'Connexion r√©ussie',
      token,
      user: {
        id: user.id,
        email: user.email,
        nom: user.nom,
        prenom: user.prenom,
        role: user.role
      }
    });

  } catch (error) {
    console.error('Erreur lors de la connexion:', error);
    res.status(500).json({ error: 'Erreur interne du serveur' });
  }
});

// V√©rification du token
app.get('/api/auth/verify', authenticateToken, async (req, res) => {
  try {
    const db = await getDatabase();
    const user = db.prepare('SELECT id, email, nom, prenom, role FROM users WHERE id = ?')
                  .get(req.user.userId);

    if (!user) {
      return res.status(404).json({ error: 'Utilisateur non trouv√©' });
    }

    res.json({
      message: 'Token valide',
      user
    });

  } catch (error) {
    console.error('Erreur lors de la v√©rification:', error);
    res.status(500).json({ error: 'Erreur interne du serveur' });
  }
});

// ROUTES DES PROPRI√âT√âS

// Lister toutes les propri√©t√©s
app.get('/api/properties', async (req, res) => {
  try {
    const db = await getDatabase();
    const properties = db.prepare(`
      SELECT p.*, u.nom, u.prenom, u.email as proprietaire_email
      FROM properties p
      LEFT JOIN users u ON p.proprietaire_id = u.id
      ORDER BY p.created_at DESC
    `).all();

    res.json({
      message: 'Propri√©t√©s r√©cup√©r√©es avec succ√®s',
      count: properties.length,
      properties
    });

  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration des propri√©t√©s:', error);
    res.status(500).json({ error: 'Erreur interne du serveur' });
  }
});

// Cr√©er une nouvelle propri√©t√©
app.post('/api/properties', authenticateToken, async (req, res) => {
  try {
    const {
      titre,
      description,
      type,
      prix,
      superficie,
      localisation,
      nombre_chambres,
      nombre_salles_bain,
      equipements
    } = req.body;

    if (!titre || !type || !prix || !localisation) {
      return res.status(400).json({ 
        error: 'Titre, type, prix et localisation sont requis' 
      });
    }

    const db = await getDatabase();
    
    const result = db.prepare(`
      INSERT INTO properties (
        titre, description, type, prix, superficie, localisation,
        nombre_chambres, nombre_salles_bain, equipements,
        proprietaire_id, statut, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'disponible', datetime('now'))
    `).run(
      titre,
      description || null,
      type,
      prix,
      superficie || null,
      localisation,
      nombre_chambres || null,
      nombre_salles_bain || null,
      equipements || null,
      req.user.userId
    );

    // R√©cup√©rer la propri√©t√© cr√©√©e avec les infos du propri√©taire
    const newProperty = db.prepare(`
      SELECT p.*, u.nom, u.prenom, u.email as proprietaire_email
      FROM properties p
      LEFT JOIN users u ON p.proprietaire_id = u.id
      WHERE p.id = ?
    `).get(result.lastInsertRowid);

    res.status(201).json({
      message: 'Propri√©t√© cr√©√©e avec succ√®s',
      property: newProperty
    });

  } catch (error) {
    console.error('Erreur lors de la cr√©ation de la propri√©t√©:', error);
    res.status(500).json({ error: 'Erreur interne du serveur' });
  }
});

// R√©cup√©rer une propri√©t√© par ID
app.get('/api/properties/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const db = await getDatabase();
    
    const property = db.prepare(`
      SELECT p.*, u.nom, u.prenom, u.email as proprietaire_email
      FROM properties p
      LEFT JOIN users u ON p.proprietaire_id = u.id
      WHERE p.id = ?
    `).get(id);

    if (!property) {
      return res.status(404).json({ 
        error: 'Propri√©t√© non trouv√©e' 
      });
    }

    res.json({
      message: 'Propri√©t√© r√©cup√©r√©e avec succ√®s',
      property
    });

  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration de la propri√©t√©:', error);
    res.status(500).json({ error: 'Erreur interne du serveur' });
  }
});

// Mettre √† jour une propri√©t√©
app.put('/api/properties/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const {
      titre,
      description,
      type,
      prix,
      superficie,
      localisation,
      nombre_chambres,
      nombre_salles_bain,
      equipements,
      statut
    } = req.body;

    const db = await getDatabase();
    
    // V√©rifier que la propri√©t√© existe et appartient √† l'utilisateur
    const existingProperty = db.prepare('SELECT proprietaire_id FROM properties WHERE id = ?').get(id);
    if (!existingProperty) {
      return res.status(404).json({ error: 'Propri√©t√© non trouv√©e' });
    }

    if (existingProperty.proprietaire_id !== req.user.userId) {
      return res.status(403).json({ error: 'Non autoris√© √† modifier cette propri√©t√©' });
    }

    // Mettre √† jour la propri√©t√©
    db.prepare(`
      UPDATE properties SET
        titre = ?, description = ?, type = ?, prix = ?, superficie = ?,
        localisation = ?, nombre_chambres = ?, nombre_salles_bain = ?,
        equipements = ?, statut = ?, updated_at = datetime('now')
      WHERE id = ?
    `).run(
      titre || null,
      description || null,
      type || null,
      prix || null,
      superficie || null,
      localisation || null,
      nombre_chambres || null,
      nombre_salles_bain || null,
      equipements || null,
      statut || 'disponible',
      id
    );

    // R√©cup√©rer la propri√©t√© mise √† jour
    const updatedProperty = db.prepare(`
      SELECT p.*, u.nom, u.prenom, u.email as proprietaire_email
      FROM properties p
      LEFT JOIN users u ON p.proprietaire_id = u.id
      WHERE p.id = ?
    `).get(id);

    res.json({
      message: 'Propri√©t√© mise √† jour avec succ√®s',
      property: updatedProperty
    });

  } catch (error) {
    console.error('Erreur lors de la mise √† jour de la propri√©t√©:', error);
    res.status(500).json({ error: 'Erreur interne du serveur' });
  }
});

// Supprimer une propri√©t√©
app.delete('/api/properties/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const db = await getDatabase();
    
    // V√©rifier que la propri√©t√© existe et appartient √† l'utilisateur
    const existingProperty = db.prepare('SELECT proprietaire_id FROM properties WHERE id = ?').get(id);
    if (!existingProperty) {
      return res.status(404).json({ error: 'Propri√©t√© non trouv√©e' });
    }

    if (existingProperty.proprietaire_id !== req.user.userId) {
      return res.status(403).json({ error: 'Non autoris√© √† supprimer cette propri√©t√©' });
    }

    // Supprimer la propri√©t√©
    db.prepare('DELETE FROM properties WHERE id = ?').run(id);

    res.json({
      message: 'Propri√©t√© supprim√©e avec succ√®s'
    });

  } catch (error) {
    console.error('Erreur lors de la suppression de la propri√©t√©:', error);
    res.status(500).json({ error: 'Erreur interne du serveur' });
  }
});

// Route pour les propri√©t√©s d'un utilisateur sp√©cifique
app.get('/api/user/properties', authenticateToken, async (req, res) => {
  try {
    const db = await getDatabase();
    const properties = db.prepare(`
      SELECT * FROM properties 
      WHERE proprietaire_id = ?
      ORDER BY created_at DESC
    `).all(req.user.userId);

    res.json({
      message: 'Propri√©t√©s de l\'utilisateur r√©cup√©r√©es avec succ√®s',
      count: properties.length,
      properties
    });

  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration des propri√©t√©s utilisateur:', error);
    res.status(500).json({ error: 'Erreur interne du serveur' });
  }
});

// Route 404
app.use('*', (req, res) => {
  res.status(404).json({ 
    error: 'Route non trouv√©e',
    availableRoutes: {
      auth: [
        'POST /api/auth/inscription',
        'POST /api/auth/connexion',
        'GET /api/auth/verify'
      ],
      properties: [
        'GET /api/properties',
        'POST /api/properties',
        'GET /api/properties/:id',
        'PUT /api/properties/:id',
        'DELETE /api/properties/:id',
        'GET /api/user/properties'
      ],
      system: [
        'GET /health',
        'GET /db-test'
      ]
    }
  });
});

// Initialisation du serveur
async function startServer() {
  try {
    console.log('üöÄ D√©marrage du serveur Teranga Foncier...');
    
    console.log('üîÑ √âTAPE 1: Initialisation base de donn√©es...');
    await getDatabase();
    console.log('‚úÖ √âTAPE 1: Base de donn√©es pr√™te');
    
    console.log('üîÑ √âTAPE 2: Configuration authentification...');
    console.log('‚úÖ √âTAPE 2: Authentification configur√©e (JWT + bcrypt)');
    
    console.log('üîÑ √âTAPE 3: Configuration routes propri√©t√©s...');
    console.log('‚úÖ √âTAPE 3: Routes propri√©t√©s configur√©es');
    
    app.listen(PORT, () => {
      console.log('\n' + '='.repeat(60));
      console.log(`‚úÖ SERVEUR COMPLET d√©marr√© sur http://localhost:${PORT}`);
      console.log('='.repeat(60));
      console.log(`üìä Health Check: http://localhost:${PORT}/health`);
      console.log(`üóÑÔ∏è DB Test: http://localhost:${PORT}/db-test`);
      console.log('\nüîê ROUTES D\'AUTHENTIFICATION:');
      console.log(`   üë§ Inscription: POST http://localhost:${PORT}/api/auth/inscription`);
      console.log(`   üîë Connexion: POST http://localhost:${PORT}/api/auth/connexion`);
      console.log(`   üîç Verify Token: GET http://localhost:${PORT}/api/auth/verify`);
      console.log('\nüè† ROUTES DES PROPRI√âT√âS:');
      console.log(`   üìã Liste: GET http://localhost:${PORT}/api/properties`);
      console.log(`   ‚ûï Cr√©er: POST http://localhost:${PORT}/api/properties`);
      console.log(`   üëÅÔ∏è D√©tail: GET http://localhost:${PORT}/api/properties/:id`);
      console.log(`   ‚úèÔ∏è Modifier: PUT http://localhost:${PORT}/api/properties/:id`);
      console.log(`   üóëÔ∏è Supprimer: DELETE http://localhost:${PORT}/api/properties/:id`);
      console.log(`   üë®‚Äçüíº Mes propri√©t√©s: GET http://localhost:${PORT}/api/user/properties`);
      console.log('\n' + '='.repeat(60));
      console.log('üéâ TOUTES LES √âTAPES TERMIN√âES - API COMPL√àTE PR√äTE !');
      console.log('='.repeat(60));
    });
    
  } catch (error) {
    console.error('‚ùå Erreur lors du d√©marrage du serveur:', error);
    process.exit(1);
  }
}

startServer();